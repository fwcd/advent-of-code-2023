include "std.bfx"

const BASE = 10;
const WORD_BYTES = 8;

function normalize_word(&value) {
  for (let i = 0; i < (WORD_BYTES - 1); i++) {
    while (value[i] >= BASE) {
      value[i] -= BASE;
      value[i + 1]++;
    }
  }
}

function print_word(&value) {
  for (let i = 0; i < WORD_BYTES; i++) {
    printd(value[WORD_BYTES - 1 - i]);
  }
}

function hash_to_sum(&hash, &sum) {
  while (hash >= BASE) {
    sum[0] += BASE;
    hash -= BASE;
    normalize_word(sum);
  }
  sum[0] += hash;
  hash = 0;
  normalize_word(sum);
}

struct BoxArray {
  [128] low;
  [128] high;
};

function box_array_get(&array, i, &out) {
  if (i < 128) {
    out = array.low[i];
  } else {
    out = array.high[i];
  }
}

function box_array_set(&array, i, value) {
  if (i < 128) {
    array.low[i] = value;
  } else {
    array.high[i] = value;
  }
}

function print_box_array(&array) {
  printc('[');
  for (let i = 0; i < 128; i++) {
    printd(array.low[i]);
    if (i != 127) {
      printc(' ');
    }
  }
  printc(']');
}

struct BoxMatrix {
  [struct BoxArray] row0,
  [struct BoxArray] row1,
  [struct BoxArray] row2,
  [struct BoxArray] row3,
  [struct BoxArray] row4,
  [struct BoxArray] row5,
  [struct BoxArray] row6;
  [struct BoxArray] row7;
  [struct BoxArray] row8;
};

function box_matrix_get(&matrix, i, j, &out) {
  switch (i) {
    case 0: box_array_get(matrix.row0, j, out);
    case 1: box_array_get(matrix.row1, j, out);
    case 2: box_array_get(matrix.row2, j, out);
    case 3: box_array_get(matrix.row3, j, out);
    case 4: box_array_get(matrix.row4, j, out);
    case 5: box_array_get(matrix.row5, j, out);
    case 6: box_array_get(matrix.row6, j, out);
    case 7: box_array_get(matrix.row7, j, out);
    case 8: box_array_get(matrix.row8, j, out);
  }
}

function box_matrix_set(&matrix, i, j, value) {
  switch (i) {
    case 0: box_array_set(matrix.row0, j, value);
    case 1: box_array_set(matrix.row1, j, value);
    case 2: box_array_set(matrix.row2, j, value);
    case 3: box_array_set(matrix.row3, j, value);
    case 4: box_array_set(matrix.row4, j, value);
    case 5: box_array_set(matrix.row5, j, value);
    case 6: box_array_set(matrix.row6, j, value);
    case 7: box_array_set(matrix.row7, j, value);
    case 8: box_array_set(matrix.row8, j, value);
  }
}

function print_box_matrix(&matrix) {
  print_box_array(matrix.row0); printc('\n');
  print_box_array(matrix.row1); printc('\n');
  print_box_array(matrix.row2); printc('\n');
  print_box_array(matrix.row3); printc('\n');
  print_box_array(matrix.row4); printc('\n');
  print_box_array(matrix.row5); printc('\n');
  print_box_array(matrix.row6); printc('\n');
  print_box_array(matrix.row7); printc('\n');
  print_box_array(matrix.row8); printc('\n');
}

struct BoxMatrix3D {
  [struct BoxMatrix] matrix0,
  [struct BoxMatrix] matrix1,
  [struct BoxMatrix] matrix2,
  [struct BoxMatrix] matrix3,
  [struct BoxMatrix] matrix4,
  [struct BoxMatrix] matrix5,
  [struct BoxMatrix] matrix6;
};

function box_matrix3d_get(&matrix, i, j, k, &out) {
  switch (i) {
    case 0: box_matrix_get(matrix.matrix0, j, k, out);
    case 1: box_matrix_get(matrix.matrix1, j, k, out);
    case 2: box_matrix_get(matrix.matrix2, j, k, out);
    case 3: box_matrix_get(matrix.matrix3, j, k, out);
    case 4: box_matrix_get(matrix.matrix4, j, k, out);
    case 5: box_matrix_get(matrix.matrix5, j, k, out);
    case 6: box_matrix_get(matrix.matrix6, j, k, out);
  }
}

function box_matrix3d_set(&matrix, i, j, k, value) {
  switch (i) {
    case 0: box_matrix_set(matrix.matrix0, j, k, value);
    case 1: box_matrix_set(matrix.matrix1, j, k, value);
    case 2: box_matrix_set(matrix.matrix2, j, k, value);
    case 3: box_matrix_set(matrix.matrix3, j, k, value);
    case 4: box_matrix_set(matrix.matrix4, j, k, value);
    case 5: box_matrix_set(matrix.matrix5, j, k, value);
    case 6: box_matrix_set(matrix.matrix6, j, k, value);
  }
}

const PARSE_STATE_NAME = 0;
const PARSE_STATE_FOCAL_LENGTH = 1;

function main() {
  let c;

  let parse_state = PARSE_STATE_NAME;
  let [WORD_BYTES] name;
  let name_index = 0;
  let focal_length = 0;

  let hash = 0;
  let [WORD_BYTES] sum;

  let [struct BoxArray] box_sizes;
  let [struct BoxMatrix3D] box_lens_names;
  let [struct BoxMatrix] box_lens_focal_lengths;

  while (true) {
    c = scanc();
    switch (c) {
      case '\n': break;
      case ',': {
        prints("Inserting ");
        for (let i = 0; i < name_index; i++) {
          printc(name[i]);
        }
        prints(" at ");
        printd(hash);
        printc('\n');

        if (focal_length == 0) {
          // We've got a dash, delete the lens
        } else {
          // Search for the lens
          let found_lens = 0;
          let size = 0;
          box_array_get(box_sizes, hash, size);
          for (let j = 0; j < size; j++) {
            for (let k = 0; k < name_index; k++) {
              let other_c;
              box_matrix3d_get(box_lens_names, k, j, hash, other_c);
              if (name[c] == other_c) {
                box_matrix_set(box_lens_focal_lengths, j, hash, focal_length);
                found_lens = 1;
              }
            }
          }
          if (!found_lens) {
            // Append the lens
            box_array_set(box_sizes, hash, size + 1);
            box_matrix_set(box_lens_focal_lengths, size, hash, focal_length);
            for (let k = 0; k < name_index; k++) {
              box_matrix3d_set(box_lens_names, k, size, hash, name[c]);
            }
          }
        }

        parse_state = PARSE_STATE_NAME;
        name_index = 0;
        hash = 0;
      }
      default: {
        if (c == '-' || c == '=') {
          parse_state = PARSE_STATE_FOCAL_LENGTH;
          focal_length = 0;
        } else {
          switch (parse_state) {
            case PARSE_STATE_NAME: {
              name[name_index] = c;
              name_index++;
              hash = (hash + c) * 17;
            }
            case PARSE_STATE_FOCAL_LENGTH: focal_length = c - '0';
          }
        }
      }
    }
  }

  print_word(sum);
}
